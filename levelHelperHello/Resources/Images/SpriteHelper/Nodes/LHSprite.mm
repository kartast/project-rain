//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////
#import "LHSprite.h"
#import "SpriteHelperLoader.h"
#import "SHDocumentLoader.h"

#import "LHSettings.h"
#import "LHAnimationNode.h"

#import "LHFixture.h"
#import "LHDictionaryExt.h"


static int untitledSpritesCount = 0;
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

@interface LHSprite (Private)

@end
////////////////////////////////////////////////////////////////////////////////
@implementation LHSprite
@synthesize usesOverloadedTransformations;
@synthesize realScale;
@synthesize swallowTouches;
@synthesize shSceneName;
@synthesize shSheetName;
@synthesize shSpriteName;
////////////////////////////////////////////////////////////////////////////////
-(void)removeSelf{
    
    if(body){
        if(body->GetWorld()->IsLocked()){
            [[LHSettings sharedInstance] markSpriteForRemoval:self];
            return;
        }
    }
    [self removeFromParentAndCleanup:YES];
}
-(void) dealloc{		
    [self removeBodyFromWorld];
                        
#ifndef LH_ARC_ENABLED   
    if(fixturesInfo){
        [fixturesInfo release];
        fixturesInfo = nil;
    }
    
    if(animation){
        [animation release];
        animation = nil;
    }

    
    if(userCustomInfo){
        [userCustomInfo release];
        userCustomInfo = nil;
    }

    if(shSceneName){
        [shSceneName release];
        shSceneName = nil;
    }
    
    [shSheetName release];
    [shSpriteName release];
    
    if(fixturesObj)
        [fixturesObj release];
        
    if(imageFile)
        [imageFile release];
        
    [uniqueName release];
    
	[super dealloc];
#endif
}
////////////////////////////////////////////////////////////////////////////////
-(void) loadUserCustomInfoFromDictionary:(NSDictionary*)dictionary{
    userCustomInfo = nil;
    if(!dictionary)return;
    
    NSString* className = [dictionary stringForKey:@"ClassName"];
    Class customClass = NSClassFromString(className);

    if(!customClass) return;
    
    userCustomInfo = [customClass performSelector:@selector(customClassInstance)];
#ifndef LH_ARC_ENABLED
    [userCustomInfo retain];
#endif
    [userCustomInfo performSelector:@selector(setPropertiesFromDictionary:) withObject:[dictionary objectForKey:@"ClassRepresentation"]];
}
//------------------------------------------------------------------------------
-(void) createFixturesFromInfoOnBody{
    
    if(fixturesInfo && fixturesObj)
    {
        [fixturesObj removeAllObjects];
        
        if(body->GetWorld()->IsLocked())
        {
            NSLog(@"ERROR: Cannot create fixture for body, because Box2d is Locked. Try changing the location on where you want to change the body. e.g Try doing it at the end of tick function");
            return;
        }
        
        b2Fixture* curFixture = body->GetFixtureList();
        
        while(curFixture)
        {
            b2Fixture* tempNextFix = curFixture->GetNext();
            body->DestroyFixture(curFixture);
            curFixture = tempNextFix;
        }
        
        for(NSDictionary* fixInfo in fixturesInfo)
        {
            LHFixture* lhFixture = [LHFixture fixtureWithDictionary:fixInfo body:body sprite:self];
            [fixturesObj addObject:lhFixture];
        }
    }
}
//------------------------------------------------------------------------------
-(void) loadPhysicalInformationFromDictionary:(NSDictionary*)dictionary{

    body = NULL;
    
    if(nil == dictionary)
        return;
    
    if([[dictionary objectForKey:@"SH_ComplexShapes"] count] == 0)
        return;
    
    
    
    b2World* world = [[LHSettings sharedInstance] activeBox2dWorld];
    NSAssert(world!=nil, @"\n\nERROR: Box2d World must not be nil - Please call [SpriteHelperLoader setBox2dWorld:world]; before creating any sprites.\n\n");
    
    b2BodyDef bodyDef;	
	
    int pType = [dictionary intForKey:@"Type"];//LH
    
	if(pType == 3) //"NO_PHYSIC"
        return;
    
	bodyDef.type = (b2BodyType)pType;
	
	CGPoint pos = self.position;	
	bodyDef.position.Set(pos.x/[[LHSettings sharedInstance] lhPtmRatio],
                         pos.y/[[LHSettings sharedInstance] lhPtmRatio]);
    
	bodyDef.angle = CC_DEGREES_TO_RADIANS(-1*self.rotation);
    
#ifndef LH_ARC_ENABLED
    bodyDef.userData = self;
#else
    bodyDef.userData = (__bridge void*)self;
#endif
    
    body = world->CreateBody(&bodyDef);    
	body->SetFixedRotation([dictionary boolForKey:@"FixedRot"]);
	        
//    body->SetGravityScale([dictionary floatForKey:@"GravityScale"]);
	body->SetSleepingAllowed([dictionary boolForKey:@"CanSleep"]);    
    body->SetBullet([dictionary boolForKey:@"IsBullet"]);

    CGPoint linearVelocity = [dictionary pointForKey:@"LinearVelocity"];
    body->SetLinearVelocity(b2Vec2(linearVelocity.x, linearVelocity.y));
    
    body->SetAngularVelocity([dictionary floatForKey:@"AngularVelocity"]);
    body->SetLinearDamping([dictionary floatForKey:@"LinearDamping"]);
    body->SetAngularDamping([dictionary floatForKey:@"AngularDamping"]);
    
    
    NSArray* fixInfo = [dictionary objectForKey:@"SH_ComplexShapes"];
    fixturesInfo = [[NSArray alloc] initWithArray:fixInfo];
    
    fixturesObj = [[NSMutableArray alloc] init];
    
    [self createFixturesFromInfoOnBody];    
}

-(void) loadAnimationsInformationFromDictionary:(NSDictionary*)dictionary{
    
    if(dictionary ==nil) return; //When sprite is loaded from SH dictionary this info is not available;
    
    //if sprite has no animation dictionary will be empty in order to make the level size smaller
    //so we test here to see if we should load anything
    if(![dictionary objectForKey:@"AnimName"]) return;
        
    
    [self prepareAnimationNamed:[dictionary stringForKey:@"AnimName"] 
                    fromSHScene:[dictionary stringForKey:@"SHScene"]];
    
    if(!animation) return;//something has gone wrong with animation loading
    
    if([dictionary boolForKey:@"AnimAtStart"])//we should pause the animation
        [animation play];
    
    [animation setLoop:[dictionary boolForKey:@"AnimLoop"]];
    [animation setRepetitions:[dictionary intForKey:@"AnimRepetitions"]];
    [animation setRestoreOriginalFrame:[dictionary boolForKey:@"AnimRestoreOriginalFrame"]];
    [animation setDelayPerUnit:[dictionary floatForKey:@"AnimSpeed"]];
}

-(void) loadInformationFromDictionary:(NSDictionary*)dictionary{
    
    if(nil != uniqueName)
        return; //compatibility with cocos2d 2.0
    
    if(nil != [dictionary objectForKey:@"UniqueName"]){
        uniqueName = [[NSMutableString alloc] initWithString:[dictionary stringForKey:@"UniqueName"]];
    }else {
        uniqueName = [[NSMutableString alloc] initWithFormat:@"UntitledSprite_%d", untitledSpritesCount];
        ++untitledSpritesCount;
    }
        
    if([dictionary objectForKey:@"SHSceneName"])
        shSceneName = [[NSString alloc] initWithString:[dictionary stringForKey:@"SHSceneName"]];
    
    if([dictionary objectForKey:@"SHSheetName"])
        shSheetName = [[NSString alloc] initWithString:[dictionary stringForKey:@"SHSheetName"]];
    if([dictionary objectForKey:@"SHSpriteName"])
        shSpriteName= [[NSString alloc] initWithString:[dictionary stringForKey:@"SHSpriteName"]];
    
    NSDictionary* texDict = [dictionary objectForKey:@"TextureProperties"];
    
    NSDictionary* shTexDict = texDict;
    if(![dictionary objectForKey:@"IsSHSprite"])//we may be loading directly from a sh dictionary
    {
        NSDictionary* shDict = [[SHDocumentLoader sharedInstance] dictionaryForSpriteNamed:[dictionary stringForKey:@"SHSpriteName"]
                                                                          inSheetNamed:[dictionary objectForKey:@"SHSheetName"]
                                                                            inDocument:[dictionary objectForKey:@"SHSceneName"]];

        if(shDict)
            shTexDict = [shDict objectForKey:@"TextureProperties"];
    }
    
    //CGRect rectInPixels = self.textureRect;
    CGRect rectInPixels = [shTexDict rectForKey:@"Frame"];
    
   // [[LHSettings sharedInstance] transformedTextureRect:self.textureRect forImage:[self imageFile]];
    
    rectInPixels = CC_RECT_POINTS_TO_PIXELS(self.textureRect);    
    
    CGSize contentSize = [shTexDict sizeForKey:@"SpriteSize"];
    
    contentSize = [[LHSettings sharedInstance] transformedSize:contentSize forImage:[self imageFile]];
    contentSize.width *= CC_CONTENT_SCALE_FACTOR();
    contentSize.height*= CC_CONTENT_SCALE_FACTOR();
    
    CCSpriteFrame* sprFrame = [CCSpriteFrame frameWithTexture:self.texture
                                                 rectInPixels:rectInPixels
                                                      rotated:[shTexDict boolForKey:@"IsRotated"] 
                                                       offset:[shTexDict pointForKey:@"TextureOffset"]
                                                 originalSize:contentSize];
    
    [self setDisplayFrame:sprFrame];

    CGPoint scale = [texDict pointForKey:@"Scale"];
    
//    CGPoint scale = [[LHSettings sharedInstance] transformedPoint:scaleVal forImage:[self imageFile]];    
    
    bool flipX = [texDict boolForKey:@"FlipX"];
    bool flipY = [texDict boolForKey:@"FlipY"];
    
    [self setFlipX:flipX];
    [self setFlipY:flipY];
    
//    NSLog(@"FLIP %@ x %d y %d", uniqueName, flipX, flipY);

    [self setScaleX:(scale.x)];
    [self setScaleY:(scale.y)];

//    [self setScaleX:(flipX ? -1*scale.x : scale.x)];
//    [self setScaleY:(flipY ? -1*scale.y : scale.y)];
    
    realScale = CGSizeMake(scale.x, scale.y);
//    realScale = CGSizeMake(scaleVal.x*[[LHSettings sharedInstance] convertRatio].x,
//                           scaleVal.y*[[LHSettings sharedInstance] convertRatio].y);
    
    CGPoint position = [[LHSettings sharedInstance] transformedPointToCocos2d:[texDict pointForKey:@"Position"]];
    [self setPosition:ccp((int)position.x, (int)position.y)];
    
    
    [self setRotation:[texDict intForKey:@"Angle"]];
    [self setColor:[texDict colorForKey:@"Color"]];
    [self setVisible:[texDict boolForKey:@"IsDrawable"]];
    [self setOpacity:[texDict floatForKey:@"Opacity"]*255.0f];
    [self setTag:[texDict intForKey:@"Tag"]];
    zOrder_ = [texDict intForKey:@"ZOrder"];
    
    NSDictionary* phyDict = [dictionary objectForKey:@"PhysicProperties"];
    if([phyDict boolForKey:@"HandledBySH"] && ![dictionary objectForKey:@"IsSHSprite"])
    {        
        NSDictionary* sprDict = [[SHDocumentLoader sharedInstance] dictionaryForSpriteNamed:shSpriteName
                                                                               inSheetNamed:shSheetName
                                                                                 inDocument:shSceneName];
        phyDict = [sprDict objectForKey:@"PhysicProperties"];
    }
    
     //we do this because we need the batch to contain the sprite before loading any animation
    if([self batchNode]){
        [[self batchNode] addChild:self z:zOrder_];
    }

    originalRect = self.textureRect;
    
    [self loadPhysicalInformationFromDictionary:phyDict];    
    [self loadAnimationsInformationFromDictionary:[dictionary objectForKey:@"AnimationsProperties"]];
    
    [self loadUserCustomInfoFromDictionary:[dictionary objectForKey:@"CustomClassInfo"]];
    
    usesOverloadedTransformations = false;
    usePhysicsForTouches = true;
    
    [self scheduleUpdate];
}

-(void)setShSceneName:(NSString *)sceneName
{
    if(shSceneName)
    {
#ifndef LH_ARC_ENABLED
        [shSceneName release];
#endif
    }
    shSceneName = [[NSString alloc] initWithString:sceneName];
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(id)initBatchSpriteWithDictionary:(NSDictionary*)dictionary batch:(LHBatch*)batch{
        
    NSDictionary* texDict = [dictionary objectForKey:@"TextureProperties"];
    CGRect rect = LHRectFromString([texDict objectForKey:@"Frame"]);    

    //NSLog(@"BATCH IMAGE PATH %@", [batch imagePath]);
    
    rect = [[LHSettings sharedInstance] transformedTextureRect:rect forImage:[batch imagePath]];
        
#if COCOS2D_VERSION >= 0x00020000
    self = [super initWithTexture:[batch texture] rect:rect];
    
    [self setBatchNode:batch];
//    if([self batchNode]){
//        [[self batchNode] addChild:self z:zOrder_];
//    }
#else
    self = [super initWithBatchNode:batch rect:rect];
#endif
    
    if (self != nil){        
        [self setImageFile:[batch imagePath]];        
        [self loadInformationFromDictionary:dictionary];
        
    //    [batch addChild:self];
    }
    return self;
}
//------------------------------------------------------------------------------
+(id)batchSpriteWithDictionary:(NSDictionary*)dictionary batch:(LHBatch*)batch{
#ifndef LH_ARC_ENABLED
    return [[[LHSprite alloc] initBatchSpriteWithDictionary:dictionary batch:batch] autorelease];
#else
    return [[LHSprite alloc] initBatchSpriteWithDictionary:dictionary batch:batch];
#endif     
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(id)initWithDictionary:(NSDictionary*)dictionary{
    
    NSString* imgPath = [[LHSettings sharedInstance] imagePath:[dictionary objectForKey:@"SheetImage"]];
    NSAssert(imgPath!=nil, @"Image path must not be nil");
    
    NSDictionary* texDict = [dictionary objectForKey:@"TextureProperties"];
    CGRect rect = LHRectFromString([texDict objectForKey:@"Frame"]);
    rect = [[LHSettings sharedInstance] transformedTextureRect:rect forImage:imgPath];

    self = [super initWithFile:imgPath rect:rect];    
    if (self != nil){
        [self setImageFile:imgPath];
        [self loadInformationFromDictionary:dictionary];
    }
    return self;
}
//------------------------------------------------------------------------------
+(id)spriteWithDictionary:(NSDictionary*)dictionary{
#ifndef LH_ARC_ENABLED
    return [[[LHSprite alloc] initWithDictionary:dictionary] autorelease];
#else
    return [[LHSprite alloc] initWithDictionary:dictionary];
#endif 
}
-(void)postInit{
    //nothing to do - method provided for overloading sprites
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
+(id)spriteWithName:(NSString*)spriteName 
          fromSheet:(NSString*)sheetName 
             SHFile:(NSString*)spriteHelperFile{

    NSDictionary* dictionary = [[SHDocumentLoader sharedInstance] dictionaryForSpriteNamed:spriteName 
                                                                              inSheetNamed:sheetName 
                                                                                inDocument:spriteHelperFile];
#ifndef LH_ARC_ENABLED
    LHSprite* sprite = [[[LHSprite alloc] initWithDictionary:dictionary] autorelease];
#else
    LHSprite* sprite = [[LHSprite alloc] initWithDictionary:dictionary];
#endif 
    
    if(sprite){      
        [sprite setShSceneName:spriteHelperFile];
    }
    return sprite;
}
//------------------------------------------------------------------------------
+(id)batchSpriteWithName:(NSString*)spriteName 
                   batch:(LHBatch*)batch{
    
    NSAssert(spriteName!=nil, @"Sprite name  must not be nil");
    NSAssert(batch!=nil, @"Batch must not be nil");
        
    NSDictionary* dictionary = [[SHDocumentLoader sharedInstance] dictionaryForSpriteNamed:spriteName 
                                                                              inSheetNamed:[batch uniqueName]
                                                                                inDocument:[batch shFile]];
#ifndef LH_ARC_ENABLED
    LHSprite* sprite = [[[LHSprite alloc] initBatchSpriteWithDictionary:dictionary batch:batch] autorelease];
#else
    LHSprite* sprite = [[LHSprite alloc] initBatchSpriteWithDictionary:dictionary batch:batch];
#endif     
    
    if(sprite){
        //[batch addChild:sprite z:[sprite zOrder]];
        [sprite setShSceneName:[batch shFile]];
    }
    return sprite;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(void) setUniqueName:(NSString*)name{
    NSAssert(name!=nil, @"UniqueName must not be nil");
    [uniqueName setString:name];
}
//------------------------------------------------------------------------------
-(NSString*)uniqueName{
    return uniqueName;   
}
//------------------------------------------------------------------------------
-(void) setBody:(b2Body*)bd{
    NSAssert(bd!=nil, @"b2Body must not be nil");
    body = bd;
}
//------------------------------------------------------------------------------
-(b2Body*)body{
    return body;
}
//------------------------------------------------------------------------------
-(bool) removeBodyFromWorld{
    if(NULL != body){
		b2World* _world = body->GetWorld();
		if(0 != _world){            
			_world->DestroyBody(body);
			body = NULL;
            
            return true;
		}
	}
    return false;
}
////////////////////////////////////////////////////////////////////////////////
-(NSString*)imageFile{
    return imageFile;
}
-(void)setImageFile:(NSString*)img{
    
#ifndef LH_ARC_ENABLED
    if(imageFile)
        [imageFile release];
#endif
    
    imageFile = [[NSString alloc] initWithString:img];
}
//------------------------------------------------------------------------------
-(CGRect)originalRect{
    return originalRect;
}
-(void)setOriginalRect:(CGRect)rect{
    originalRect = rect;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(void)setPosition:(CGPoint)pos
{
    if(usesOverloadedTransformations)
        [self transformPosition:pos];
    else {
        [super setPosition:pos];
    }
}
-(void)setRotation:(float)rot
{
    if(usesOverloadedTransformations)
        [self transformRotation:rot];
    else {
        [super setRotation:rot];
    }
}
//------------------------------------------------------------------------------
-(void)setScale:(float)scale{

    if(usesOverloadedTransformations)
        [self transformScale:scale];
    else {
        [super setScale:scale];
    }
}
-(void)setScaleX:(float)scaleX{
    if(usesOverloadedTransformations)
        [self transformScaleX:scaleX];
    else {
        [super setScaleX:scaleX];
    }
}

-(void)setScaleY:(float)scaleY{
    if(usesOverloadedTransformations)
        [self transformScaleY:scaleY];
    else {
        [super setScaleY:scaleY];
    }
}
//------------------------------------------------------------------------------
-(void) transformPosition:(CGPoint)pos{
    [super setPosition:pos];
    if(0 != body){
        b2Vec2 boxPosition = [SpriteHelperLoader pointsToMeters:pos];
        float angle = CC_DEGREES_TO_RADIANS(-1*super.rotation);
        body->SetTransform(boxPosition, angle);
    }
}
//------------------------------------------------------------------------------
-(void)transformRotation:(float)rot{
    
    [super setRotation:rot];
    if(0 != body){
        b2Vec2 boxPosition = [SpriteHelperLoader pointsToMeters:super.position];
        float angle = CC_DEGREES_TO_RADIANS(-1*rot);
        body->SetTransform(boxPosition, angle);
    }
}
//------------------------------------------------------------------------------
-(void) transformScale:(float)scale{

    [super setScale:scale];
    
    if(0 != body){
        [self createFixturesFromInfoOnBody];
    }
}
-(void) transformScaleX:(float)scaleX{

    [super setScaleX:scaleX];
    
    if(0 != body){
        [self createFixturesFromInfoOnBody];        
    }

}
-(void) transformScaleY:(float)scaleY{
    [super setScaleY:scaleY];
    
    if(0 != body){
        [self createFixturesFromInfoOnBody];
    }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(void)update:(ccTime)dt{    
    if(animation)
        [animation update:dt];
    
    [[LHSettings sharedInstance] removeMarkedSprites];
}
//------------------------------------------------------------------------------
-(void) prepareAnimationNamed:(NSString*)animName fromSHScene:(NSString *)shScene{

    NSDictionary* animDict = [[SHDocumentLoader sharedInstance] dictionaryForAnimationNamed:animName
                                                                                 inDocument:shScene];
    if(animation)
    {
#ifndef LH_ARC_ENABLED
        [animation release];
#endif
        animation = nil;
    }
    
    if(!animDict) {
        NSLog(@"ERROR: SpriteHelper document %@ for animation %@ needs to be updated. Animation is canceled.", shScene, animName);
        return;
    }
        
    NSString* textureFile = [animDict stringForKey:@"SheetImage"];
    NSString* animSheet = [animDict stringForKey:@"SheetName"];

    animation = [[LHAnimationNode alloc] initWithDictionary:animDict 
                                                   onSprite:self];

    if(![shSheetName isEqualToString:animSheet]){
        if(nil != textureFile){
            
#if COCOS2D_VERSION >= 0x00020000
            NSString* filePath = [[CCFileUtils sharedFileUtils] fullPathFromRelativePath:textureFile];
#else
            NSString* filePath = [CCFileUtils fullPathFromRelativePath:textureFile];
#endif
    
            if(filePath){
                CCTexture2D* newTexture = [[CCTextureCache sharedTextureCache] addImage:filePath];
                
                if(newTexture){
                    //if sprite is render by a batch node we need to remove if from the batch and 
                    //move it on the layer that contains the batch
                    LHBatch* parentBatch = (LHBatch*)[self batchNode];
                        
                    if(parentBatch){                       
                        [self removeFromParentAndCleanup:NO];
                        
                        [animation setOldBatch:parentBatch];
                        //we need to keep the z order so its batch z + sprite z 
                        if([parentBatch parent]){                            
                            [[parentBatch parent] addChild:self z:[parentBatch zOrder] + [self zOrder]];
                        }
                        else {
                            NSLog(@"ERROR: Sprite is render by batch node, but batch node has no parent.");
                        }
                    }   
                    else {
                        [animation setOldTexture:self.texture];
                    }
                    
                    [self setTexture:newTexture];
                    #ifndef LH_ARC_ENABLED
                    [shSheetName release];
                    #endif
                    shSheetName = [[NSString alloc] initWithString:animSheet];
                }
            }
        }
        else{
            #ifndef LH_ARC_ENABLED
            [animation release];
            #endif
            NSLog(@"ERROR: Image file %@ could not be found. Please add it in the resource folder.", textureFile);
        }
    }

    if(animation){
        [animation setOldRect:originalRect];
        [animation prepare];
    
    }
}
//------------------------------------------------------------------------------
-(void) playAnimation{ if(animation)[animation play];}
//------------------------------------------------------------------------------
-(void) pauseAnimation{ if(animation)[animation setPaused:YES];}
//------------------------------------------------------------------------------
-(void) restartAnimation{ if(animation)[animation setPaused:YES];}
//------------------------------------------------------------------------------
-(bool) isAnimationPaused{ if(!animation)return false;
    return [animation paused];
}
//------------------------------------------------------------------------------
-(void) stopAnimation{

    if(!animation)return;

    [animation restoreFrame];

    #ifndef LH_ARC_ENABLED
    [animation release];
    #endif
    animation = nil;
}
//------------------------------------------------------------------------------
-(NSString*) animationName{ if(animation) return [animation uniqueName];
    return @"";
}
//------------------------------------------------------------------------------
-(int) numberOfFrames{ if(animation)return [animation numberOfFrames];    
    return -1;
}
//------------------------------------------------------------------------------
-(float) animationDelayPerUnit{
    if(animation){return [animation delayPerUnit];}
    return 0.0f;
}
-(void) setAnimationDelayPerUnit:(float)d{
    if(animation){ if(d < 0.0f) d = 0.0f; [animation setDelayPerUnit:d];}
}
//------------------------------------------------------------------------------
-(float)animationDuration{
    if(animation)return [animation totalTime];
    return 0.0f;
}
//------------------------------------------------------------------------------
-(void) setFrame:(int)frmNo{ if(animation)[animation setFrame:frmNo];}
//------------------------------------------------------------------------------
-(int) currentFrame{     
    if(animation) return [animation currentFrame];    
    return -1;
}
//------------------------------------------------------------------------------
-(void) nextFrame{ if(animation)[animation nextFrame];}
//------------------------------------------------------------------------------
-(void) prevFrame{ if(animation)[animation prevFrame];}
//------------------------------------------------------------------------------
-(void) nextFrameAndRepeat{ if(animation)[animation nextFrameAndRepeat];}
//------------------------------------------------------------------------------
-(void) prevFrameAndRepeat{ if(animation)[animation prevFrameAndRepeat];}
//------------------------------------------------------------------------------
-(bool) isAtLastFrame{ if(animation)return [animation isAtLastFrame];
    return false;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
+(NSString*) uniqueNameForBody:(b2Body*)body{
    
#ifndef LH_ARC_ENABLED
    id spr = (id)body->GetUserData();
#else
    id spr = (__bridge id)body->GetUserData();
#endif
    
    if([LHSprite isLHSprite:spr])
        return [spr uniqueName];
        
    return nil;
}
//------------------------------------------------------------------------------
+(LHSprite*) spriteForBody:(b2Body*)body
{
    if(0 == body)
        return nil;
#ifndef LH_ARC_ENABLED 
    id spr = (id)body->GetUserData();
#else
    id spr = (__bridge id)body->GetUserData();
#endif
    
    if([LHSprite isLHSprite:spr])
        return spr;
    
    return nil;    
}
//------------------------------------------------------------------------------
+(int) tagForBody:(b2Body*)body{
    if(0 != body){
        #ifndef LH_ARC_ENABLED 
        CCNode* spr = (CCNode*)body->GetUserData();
        #else
        CCNode* spr = (__bridge CCNode*)body->GetUserData();
        #endif
        if(nil != spr){
            return [spr tag];
        }
    }
    return -1;
}
//------------------------------------------------------------------------------
+(bool) isLHSprite:(id)object{
    if([object isKindOfClass:[LHSprite class]]){
        return true;
    }
    return false;
}
////////////////////////////////////////////////////////////////////////////////
- (NSComparisonResult)sortAscending:(LHSprite *)other{

    if(nil == other)
        return NSOrderedSame;
    
    return [uniqueName compare:[other uniqueName]];
}
//------------------------------------------------------------------------------
- (NSComparisonResult)sortDescending:(LHSprite *)other
{		
    if(nil == other)
        return NSOrderedSame;

    NSComparisonResult result = [uniqueName compare:[other uniqueName]];
    
    if(result == NSOrderedDescending)
        return NSOrderedAscending;
    else if(result == NSOrderedAscending)
        return NSOrderedDescending;
    
    return NSOrderedSame;           
}
//------------------------------------------------------------------------------
-(void)setCollisionFilterCategory:(int)category{
    if(body == nil)
        return;
    
    b2Fixture* curFix = body->GetFixtureList();
    while (curFix) {
        
        b2Filter curFilter = curFix->GetFilterData();

        b2Filter filter;
        filter.categoryBits = category;
        filter.maskBits     = curFilter.maskBits;
        filter.groupIndex   = curFilter.groupIndex;

        curFix->SetFilterData(filter);        
        curFix = curFix->GetNext();
    }
}
-(void)setCollisionFilterMask:(int)mask{
    if(body == nil)
        return;

    b2Fixture* curFix = body->GetFixtureList();
    while (curFix) {
        
        b2Filter curFilter = curFix->GetFilterData();
        
        b2Filter filter;
        filter.categoryBits = curFilter.categoryBits;
        filter.maskBits     = mask;
        filter.groupIndex   = curFilter.groupIndex;
        
        curFix->SetFilterData(filter);        
        curFix = curFix->GetNext();
    }
}
-(void)setCollisionFilterGroup:(int)group{
    if(body == nil)
        return;
    b2Fixture* curFix = body->GetFixtureList();
    while (curFix) {
        
        b2Filter curFilter = curFix->GetFilterData();
        
        b2Filter filter;
        filter.categoryBits = curFilter.categoryBits;
        filter.maskBits     = curFilter.maskBits;
        filter.groupIndex   = group;
        
        curFix->SetFilterData(filter);        
        curFix = curFix->GetNext();
    }
}

//TYPE CONVERSION
//------------------------------------------------------------------------------
-(void)makeDynamic{
    
    if(body == nil)
        return;
    
    body->SetType(b2_dynamicBody);    
}
-(void)makeStatic{
    if(body == nil)
        return;
    
    body->SetType(b2_staticBody);
}
-(void)makeKinematic{
    if(body == nil)
        return;

    body->SetType(b2_kinematicBody);
}
//------------------------------------------------------------------------------
@end
